/* automatically generated by rust-bindgen */

pub const PI: f64 = 3.141592653589793;
pub const DEG2RAD: f64 = 0.017453292519943295;
pub const RAD2DEG: f64 = 57.29577951308232;
pub const FLAG_SHOW_LOGO: ::std::os::raw::c_uint = 1;
pub const FLAG_FULLSCREEN_MODE: ::std::os::raw::c_uint = 2;
pub const FLAG_WINDOW_RESIZABLE: ::std::os::raw::c_uint = 4;
pub const FLAG_WINDOW_DECORATED: ::std::os::raw::c_uint = 8;
pub const FLAG_WINDOW_TRANSPARENT: ::std::os::raw::c_uint = 16;
pub const FLAG_MSAA_4X_HINT: ::std::os::raw::c_uint = 32;
pub const FLAG_VSYNC_HINT: ::std::os::raw::c_uint = 64;
pub const KEY_SPACE: ::std::os::raw::c_int = 32;
pub const KEY_ESCAPE: ::std::os::raw::c_int = 256;
pub const KEY_ENTER: ::std::os::raw::c_int = 257;
pub const KEY_BACKSPACE: ::std::os::raw::c_int = 259;
pub const KEY_RIGHT: ::std::os::raw::c_int = 262;
pub const KEY_LEFT: ::std::os::raw::c_int = 263;
pub const KEY_DOWN: ::std::os::raw::c_int = 264;
pub const KEY_UP: ::std::os::raw::c_int = 265;
pub const KEY_F1: ::std::os::raw::c_int = 290;
pub const KEY_F2: ::std::os::raw::c_int = 291;
pub const KEY_F3: ::std::os::raw::c_int = 292;
pub const KEY_F4: ::std::os::raw::c_int = 293;
pub const KEY_F5: ::std::os::raw::c_int = 294;
pub const KEY_F6: ::std::os::raw::c_int = 295;
pub const KEY_F7: ::std::os::raw::c_int = 296;
pub const KEY_F8: ::std::os::raw::c_int = 297;
pub const KEY_F9: ::std::os::raw::c_int = 298;
pub const KEY_F10: ::std::os::raw::c_int = 299;
pub const KEY_F11: ::std::os::raw::c_int = 300;
pub const KEY_F12: ::std::os::raw::c_int = 301;
pub const KEY_LEFT_SHIFT: ::std::os::raw::c_int = 340;
pub const KEY_LEFT_CONTROL: ::std::os::raw::c_int = 341;
pub const KEY_LEFT_ALT: ::std::os::raw::c_int = 342;
pub const KEY_RIGHT_SHIFT: ::std::os::raw::c_int = 344;
pub const KEY_RIGHT_CONTROL: ::std::os::raw::c_int = 345;
pub const KEY_RIGHT_ALT: ::std::os::raw::c_int = 346;
pub const KEY_ZERO: ::std::os::raw::c_int = 48;
pub const KEY_ONE: ::std::os::raw::c_int = 49;
pub const KEY_TWO: ::std::os::raw::c_int = 50;
pub const KEY_THREE: ::std::os::raw::c_int = 51;
pub const KEY_FOUR: ::std::os::raw::c_int = 52;
pub const KEY_FIVE: ::std::os::raw::c_int = 53;
pub const KEY_SIX: ::std::os::raw::c_int = 54;
pub const KEY_SEVEN: ::std::os::raw::c_int = 55;
pub const KEY_EIGHT: ::std::os::raw::c_int = 56;
pub const KEY_NINE: ::std::os::raw::c_int = 57;
pub const KEY_A: ::std::os::raw::c_int = 65;
pub const KEY_B: ::std::os::raw::c_int = 66;
pub const KEY_C: ::std::os::raw::c_int = 67;
pub const KEY_D: ::std::os::raw::c_int = 68;
pub const KEY_E: ::std::os::raw::c_int = 69;
pub const KEY_F: ::std::os::raw::c_int = 70;
pub const KEY_G: ::std::os::raw::c_int = 71;
pub const KEY_H: ::std::os::raw::c_int = 72;
pub const KEY_I: ::std::os::raw::c_int = 73;
pub const KEY_J: ::std::os::raw::c_int = 74;
pub const KEY_K: ::std::os::raw::c_int = 75;
pub const KEY_L: ::std::os::raw::c_int = 76;
pub const KEY_M: ::std::os::raw::c_int = 77;
pub const KEY_N: ::std::os::raw::c_int = 78;
pub const KEY_O: ::std::os::raw::c_int = 79;
pub const KEY_P: ::std::os::raw::c_int = 80;
pub const KEY_Q: ::std::os::raw::c_int = 81;
pub const KEY_R: ::std::os::raw::c_int = 82;
pub const KEY_S: ::std::os::raw::c_int = 83;
pub const KEY_T: ::std::os::raw::c_int = 84;
pub const KEY_U: ::std::os::raw::c_int = 85;
pub const KEY_V: ::std::os::raw::c_int = 86;
pub const KEY_W: ::std::os::raw::c_int = 87;
pub const KEY_X: ::std::os::raw::c_int = 88;
pub const KEY_Y: ::std::os::raw::c_int = 89;
pub const KEY_Z: ::std::os::raw::c_int = 90;
pub const MOUSE_LEFT_BUTTON: ::std::os::raw::c_int = 0;
pub const MOUSE_RIGHT_BUTTON: ::std::os::raw::c_int = 1;
pub const MOUSE_MIDDLE_BUTTON: ::std::os::raw::c_int = 2;
pub const MAX_TOUCH_POINTS: ::std::os::raw::c_int = 2;
pub const GAMEPAD_PLAYER1: ::std::os::raw::c_int = 0;
pub const GAMEPAD_PLAYER2: ::std::os::raw::c_int = 1;
pub const GAMEPAD_PLAYER3: ::std::os::raw::c_int = 2;
pub const GAMEPAD_PLAYER4: ::std::os::raw::c_int = 3;
pub const GAMEPAD_PS3_BUTTON_TRIANGLE: ::std::os::raw::c_int = 0;
pub const GAMEPAD_PS3_BUTTON_CIRCLE: ::std::os::raw::c_int = 1;
pub const GAMEPAD_PS3_BUTTON_CROSS: ::std::os::raw::c_int = 2;
pub const GAMEPAD_PS3_BUTTON_SQUARE: ::std::os::raw::c_int = 3;
pub const GAMEPAD_PS3_BUTTON_L1: ::std::os::raw::c_int = 6;
pub const GAMEPAD_PS3_BUTTON_R1: ::std::os::raw::c_int = 7;
pub const GAMEPAD_PS3_BUTTON_L2: ::std::os::raw::c_int = 4;
pub const GAMEPAD_PS3_BUTTON_R2: ::std::os::raw::c_int = 5;
pub const GAMEPAD_PS3_BUTTON_START: ::std::os::raw::c_int = 8;
pub const GAMEPAD_PS3_BUTTON_SELECT: ::std::os::raw::c_int = 9;
pub const GAMEPAD_PS3_BUTTON_UP: ::std::os::raw::c_int = 24;
pub const GAMEPAD_PS3_BUTTON_RIGHT: ::std::os::raw::c_int = 25;
pub const GAMEPAD_PS3_BUTTON_DOWN: ::std::os::raw::c_int = 26;
pub const GAMEPAD_PS3_BUTTON_LEFT: ::std::os::raw::c_int = 27;
pub const GAMEPAD_PS3_BUTTON_PS: ::std::os::raw::c_int = 12;
pub const GAMEPAD_PS3_AXIS_LEFT_X: ::std::os::raw::c_int = 0;
pub const GAMEPAD_PS3_AXIS_LEFT_Y: ::std::os::raw::c_int = 1;
pub const GAMEPAD_PS3_AXIS_RIGHT_X: ::std::os::raw::c_int = 2;
pub const GAMEPAD_PS3_AXIS_RIGHT_Y: ::std::os::raw::c_int = 5;
pub const GAMEPAD_PS3_AXIS_L2: ::std::os::raw::c_int = 3;
pub const GAMEPAD_PS3_AXIS_R2: ::std::os::raw::c_int = 4;
pub const GAMEPAD_XBOX_BUTTON_A: ::std::os::raw::c_int = 0;
pub const GAMEPAD_XBOX_BUTTON_B: ::std::os::raw::c_int = 1;
pub const GAMEPAD_XBOX_BUTTON_X: ::std::os::raw::c_int = 2;
pub const GAMEPAD_XBOX_BUTTON_Y: ::std::os::raw::c_int = 3;
pub const GAMEPAD_XBOX_BUTTON_LB: ::std::os::raw::c_int = 4;
pub const GAMEPAD_XBOX_BUTTON_RB: ::std::os::raw::c_int = 5;
pub const GAMEPAD_XBOX_BUTTON_SELECT: ::std::os::raw::c_int = 6;
pub const GAMEPAD_XBOX_BUTTON_START: ::std::os::raw::c_int = 7;
pub const GAMEPAD_XBOX_BUTTON_UP: ::std::os::raw::c_int = 10;
pub const GAMEPAD_XBOX_BUTTON_RIGHT: ::std::os::raw::c_int = 11;
pub const GAMEPAD_XBOX_BUTTON_DOWN: ::std::os::raw::c_int = 12;
pub const GAMEPAD_XBOX_BUTTON_LEFT: ::std::os::raw::c_int = 13;
pub const GAMEPAD_XBOX_BUTTON_HOME: ::std::os::raw::c_int = 8;
pub const GAMEPAD_XBOX_AXIS_LEFT_X: ::std::os::raw::c_int = 0;
pub const GAMEPAD_XBOX_AXIS_LEFT_Y: ::std::os::raw::c_int = 1;
pub const GAMEPAD_XBOX_AXIS_RIGHT_X: ::std::os::raw::c_int = 2;
pub const GAMEPAD_XBOX_AXIS_RIGHT_Y: ::std::os::raw::c_int = 3;
pub const GAMEPAD_XBOX_AXIS_LT: ::std::os::raw::c_int = 4;
pub const GAMEPAD_XBOX_AXIS_RT: ::std::os::raw::c_int = 5;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum bool_ { false_ = 0, true_ = 1, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Vector2 {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_Vector2() {
    assert_eq!(::std::mem::size_of::<Vector2>() , 8usize , concat ! (
               "Size of: " , stringify ! ( Vector2 ) ));
    assert_eq! (::std::mem::align_of::<Vector2>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( Vector2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Vector2 ) ) . x as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( Vector2 ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Vector2 ) ) . y as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! ( Vector2 ) , "::" ,
                stringify ! ( y ) ));
}
impl Clone for Vector2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Vector3 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[test]
fn bindgen_test_layout_Vector3() {
    assert_eq!(::std::mem::size_of::<Vector3>() , 12usize , concat ! (
               "Size of: " , stringify ! ( Vector3 ) ));
    assert_eq! (::std::mem::align_of::<Vector3>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( Vector3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Vector3 ) ) . x as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( Vector3 ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Vector3 ) ) . y as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! ( Vector3 ) , "::" ,
                stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Vector3 ) ) . z as * const _ as usize } ,
                8usize , concat ! (
                "Alignment of field: " , stringify ! ( Vector3 ) , "::" ,
                stringify ! ( z ) ));
}
impl Clone for Vector3 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Matrix {
    pub m0: f32,
    pub m4: f32,
    pub m8: f32,
    pub m12: f32,
    pub m1: f32,
    pub m5: f32,
    pub m9: f32,
    pub m13: f32,
    pub m2: f32,
    pub m6: f32,
    pub m10: f32,
    pub m14: f32,
    pub m3: f32,
    pub m7: f32,
    pub m11: f32,
    pub m15: f32,
}
#[test]
fn bindgen_test_layout_Matrix() {
    assert_eq!(::std::mem::size_of::<Matrix>() , 64usize , concat ! (
               "Size of: " , stringify ! ( Matrix ) ));
    assert_eq! (::std::mem::align_of::<Matrix>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( Matrix ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Matrix ) ) . m0 as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( Matrix ) , "::" ,
                stringify ! ( m0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Matrix ) ) . m4 as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! ( Matrix ) , "::" ,
                stringify ! ( m4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Matrix ) ) . m8 as * const _ as usize } ,
                8usize , concat ! (
                "Alignment of field: " , stringify ! ( Matrix ) , "::" ,
                stringify ! ( m8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Matrix ) ) . m12 as * const _ as usize }
                , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( Matrix ) , "::" ,
                stringify ! ( m12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Matrix ) ) . m1 as * const _ as usize } ,
                16usize , concat ! (
                "Alignment of field: " , stringify ! ( Matrix ) , "::" ,
                stringify ! ( m1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Matrix ) ) . m5 as * const _ as usize } ,
                20usize , concat ! (
                "Alignment of field: " , stringify ! ( Matrix ) , "::" ,
                stringify ! ( m5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Matrix ) ) . m9 as * const _ as usize } ,
                24usize , concat ! (
                "Alignment of field: " , stringify ! ( Matrix ) , "::" ,
                stringify ! ( m9 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Matrix ) ) . m13 as * const _ as usize }
                , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( Matrix ) , "::" ,
                stringify ! ( m13 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Matrix ) ) . m2 as * const _ as usize } ,
                32usize , concat ! (
                "Alignment of field: " , stringify ! ( Matrix ) , "::" ,
                stringify ! ( m2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Matrix ) ) . m6 as * const _ as usize } ,
                36usize , concat ! (
                "Alignment of field: " , stringify ! ( Matrix ) , "::" ,
                stringify ! ( m6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Matrix ) ) . m10 as * const _ as usize }
                , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( Matrix ) , "::" ,
                stringify ! ( m10 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Matrix ) ) . m14 as * const _ as usize }
                , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( Matrix ) , "::" ,
                stringify ! ( m14 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Matrix ) ) . m3 as * const _ as usize } ,
                48usize , concat ! (
                "Alignment of field: " , stringify ! ( Matrix ) , "::" ,
                stringify ! ( m3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Matrix ) ) . m7 as * const _ as usize } ,
                52usize , concat ! (
                "Alignment of field: " , stringify ! ( Matrix ) , "::" ,
                stringify ! ( m7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Matrix ) ) . m11 as * const _ as usize }
                , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( Matrix ) , "::" ,
                stringify ! ( m11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Matrix ) ) . m15 as * const _ as usize }
                , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( Matrix ) , "::" ,
                stringify ! ( m15 ) ));
}
impl Clone for Matrix {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Color {
    pub r: ::std::os::raw::c_uchar,
    pub g: ::std::os::raw::c_uchar,
    pub b: ::std::os::raw::c_uchar,
    pub a: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_Color() {
    assert_eq!(::std::mem::size_of::<Color>() , 4usize , concat ! (
               "Size of: " , stringify ! ( Color ) ));
    assert_eq! (::std::mem::align_of::<Color>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( Color ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Color ) ) . r as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( Color ) , "::" ,
                stringify ! ( r ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Color ) ) . g as * const _ as usize } ,
                1usize , concat ! (
                "Alignment of field: " , stringify ! ( Color ) , "::" ,
                stringify ! ( g ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Color ) ) . b as * const _ as usize } ,
                2usize , concat ! (
                "Alignment of field: " , stringify ! ( Color ) , "::" ,
                stringify ! ( b ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Color ) ) . a as * const _ as usize } ,
                3usize , concat ! (
                "Alignment of field: " , stringify ! ( Color ) , "::" ,
                stringify ! ( a ) ));
}
impl Clone for Color {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Rectangle {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Rectangle() {
    assert_eq!(::std::mem::size_of::<Rectangle>() , 16usize , concat ! (
               "Size of: " , stringify ! ( Rectangle ) ));
    assert_eq! (::std::mem::align_of::<Rectangle>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( Rectangle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Rectangle ) ) . x as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Rectangle ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Rectangle ) ) . y as * const _ as usize }
                , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( Rectangle ) , "::" ,
                stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Rectangle ) ) . width as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Rectangle ) , "::" ,
                stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Rectangle ) ) . height as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( Rectangle ) , "::" ,
                stringify ! ( height ) ));
}
impl Clone for Rectangle {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Image {
    pub data: *mut ::std::os::raw::c_void,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub mipmaps: ::std::os::raw::c_int,
    pub format: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Image() {
    assert_eq!(::std::mem::size_of::<Image>() , 24usize , concat ! (
               "Size of: " , stringify ! ( Image ) ));
    assert_eq! (::std::mem::align_of::<Image>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Image ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Image ) ) . data as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Image ) , "::" ,
                stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Image ) ) . width as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Image ) , "::" ,
                stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Image ) ) . height as * const _ as usize
                } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( Image ) , "::" ,
                stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Image ) ) . mipmaps as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( Image ) , "::" ,
                stringify ! ( mipmaps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Image ) ) . format as * const _ as usize
                } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( Image ) , "::" ,
                stringify ! ( format ) ));
}
impl Clone for Image {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Texture2D {
    pub id: ::std::os::raw::c_uint,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub mipmaps: ::std::os::raw::c_int,
    pub format: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Texture2D() {
    assert_eq!(::std::mem::size_of::<Texture2D>() , 20usize , concat ! (
               "Size of: " , stringify ! ( Texture2D ) ));
    assert_eq! (::std::mem::align_of::<Texture2D>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( Texture2D ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Texture2D ) ) . id as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Texture2D ) , "::" ,
                stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Texture2D ) ) . width as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( Texture2D ) , "::" ,
                stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Texture2D ) ) . height as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Texture2D ) , "::" ,
                stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Texture2D ) ) . mipmaps as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( Texture2D ) , "::" ,
                stringify ! ( mipmaps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Texture2D ) ) . format as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( Texture2D ) , "::" ,
                stringify ! ( format ) ));
}
impl Clone for Texture2D {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RenderTexture2D {
    pub id: ::std::os::raw::c_uint,
    pub texture: Texture2D,
    pub depth: Texture2D,
}
#[test]
fn bindgen_test_layout_RenderTexture2D() {
    assert_eq!(::std::mem::size_of::<RenderTexture2D>() , 44usize , concat ! (
               "Size of: " , stringify ! ( RenderTexture2D ) ));
    assert_eq! (::std::mem::align_of::<RenderTexture2D>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( RenderTexture2D ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RenderTexture2D ) ) . id as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RenderTexture2D ) ,
                "::" , stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RenderTexture2D ) ) . texture as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( RenderTexture2D ) ,
                "::" , stringify ! ( texture ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RenderTexture2D ) ) . depth as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( RenderTexture2D ) ,
                "::" , stringify ! ( depth ) ));
}
impl Clone for RenderTexture2D {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CharInfo {
    pub value: ::std::os::raw::c_int,
    pub rec: Rectangle,
    pub offsetX: ::std::os::raw::c_int,
    pub offsetY: ::std::os::raw::c_int,
    pub advanceX: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CharInfo() {
    assert_eq!(::std::mem::size_of::<CharInfo>() , 32usize , concat ! (
               "Size of: " , stringify ! ( CharInfo ) ));
    assert_eq! (::std::mem::align_of::<CharInfo>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( CharInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CharInfo ) ) . value as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CharInfo ) , "::" ,
                stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CharInfo ) ) . rec as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( CharInfo ) , "::" ,
                stringify ! ( rec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CharInfo ) ) . offsetX as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( CharInfo ) , "::" ,
                stringify ! ( offsetX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CharInfo ) ) . offsetY as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( CharInfo ) , "::" ,
                stringify ! ( offsetY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CharInfo ) ) . advanceX as * const _ as
                usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( CharInfo ) , "::" ,
                stringify ! ( advanceX ) ));
}
impl Clone for CharInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SpriteFont {
    pub texture: Texture2D,
    pub baseSize: ::std::os::raw::c_int,
    pub charsCount: ::std::os::raw::c_int,
    pub chars: *mut CharInfo,
}
#[test]
fn bindgen_test_layout_SpriteFont() {
    assert_eq!(::std::mem::size_of::<SpriteFont>() , 40usize , concat ! (
               "Size of: " , stringify ! ( SpriteFont ) ));
    assert_eq! (::std::mem::align_of::<SpriteFont>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( SpriteFont ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SpriteFont ) ) . texture as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SpriteFont ) , "::" ,
                stringify ! ( texture ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SpriteFont ) ) . baseSize as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( SpriteFont ) , "::" ,
                stringify ! ( baseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SpriteFont ) ) . charsCount as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( SpriteFont ) , "::" ,
                stringify ! ( charsCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SpriteFont ) ) . chars as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( SpriteFont ) , "::" ,
                stringify ! ( chars ) ));
}
impl Clone for SpriteFont {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Camera {
    pub position: Vector3,
    pub target: Vector3,
    pub up: Vector3,
    pub fovy: f32,
}
#[test]
fn bindgen_test_layout_Camera() {
    assert_eq!(::std::mem::size_of::<Camera>() , 40usize , concat ! (
               "Size of: " , stringify ! ( Camera ) ));
    assert_eq! (::std::mem::align_of::<Camera>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( Camera ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Camera ) ) . position as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Camera ) , "::" ,
                stringify ! ( position ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Camera ) ) . target as * const _ as usize
                } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( Camera ) , "::" ,
                stringify ! ( target ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Camera ) ) . up as * const _ as usize } ,
                24usize , concat ! (
                "Alignment of field: " , stringify ! ( Camera ) , "::" ,
                stringify ! ( up ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Camera ) ) . fovy as * const _ as usize }
                , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( Camera ) , "::" ,
                stringify ! ( fovy ) ));
}
impl Clone for Camera {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Camera2D {
    pub offset: Vector2,
    pub target: Vector2,
    pub rotation: f32,
    pub zoom: f32,
}
#[test]
fn bindgen_test_layout_Camera2D() {
    assert_eq!(::std::mem::size_of::<Camera2D>() , 24usize , concat ! (
               "Size of: " , stringify ! ( Camera2D ) ));
    assert_eq! (::std::mem::align_of::<Camera2D>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( Camera2D ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Camera2D ) ) . offset as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Camera2D ) , "::" ,
                stringify ! ( offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Camera2D ) ) . target as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Camera2D ) , "::" ,
                stringify ! ( target ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Camera2D ) ) . rotation as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( Camera2D ) , "::" ,
                stringify ! ( rotation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Camera2D ) ) . zoom as * const _ as usize
                } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( Camera2D ) , "::" ,
                stringify ! ( zoom ) ));
}
impl Clone for Camera2D {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct BoundingBox {
    pub min: Vector3,
    pub max: Vector3,
}
#[test]
fn bindgen_test_layout_BoundingBox() {
    assert_eq!(::std::mem::size_of::<BoundingBox>() , 24usize , concat ! (
               "Size of: " , stringify ! ( BoundingBox ) ));
    assert_eq! (::std::mem::align_of::<BoundingBox>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( BoundingBox ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BoundingBox ) ) . min as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( BoundingBox ) , "::" ,
                stringify ! ( min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const BoundingBox ) ) . max as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( BoundingBox ) , "::" ,
                stringify ! ( max ) ));
}
impl Clone for BoundingBox {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Mesh {
    pub vertexCount: ::std::os::raw::c_int,
    pub triangleCount: ::std::os::raw::c_int,
    pub vertices: *mut f32,
    pub texcoords: *mut f32,
    pub texcoords2: *mut f32,
    pub normals: *mut f32,
    pub tangents: *mut f32,
    pub colors: *mut ::std::os::raw::c_uchar,
    pub indices: *mut ::std::os::raw::c_ushort,
    pub vaoId: ::std::os::raw::c_uint,
    pub vboId: [::std::os::raw::c_uint; 7usize],
}
#[test]
fn bindgen_test_layout_Mesh() {
    assert_eq!(::std::mem::size_of::<Mesh>() , 96usize , concat ! (
               "Size of: " , stringify ! ( Mesh ) ));
    assert_eq! (::std::mem::align_of::<Mesh>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Mesh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Mesh ) ) . vertexCount as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Mesh ) , "::" ,
                stringify ! ( vertexCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Mesh ) ) . triangleCount as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( Mesh ) , "::" ,
                stringify ! ( triangleCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Mesh ) ) . vertices as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Mesh ) , "::" ,
                stringify ! ( vertices ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Mesh ) ) . texcoords as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( Mesh ) , "::" ,
                stringify ! ( texcoords ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Mesh ) ) . texcoords2 as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( Mesh ) , "::" ,
                stringify ! ( texcoords2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Mesh ) ) . normals as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( Mesh ) , "::" ,
                stringify ! ( normals ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Mesh ) ) . tangents as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( Mesh ) , "::" ,
                stringify ! ( tangents ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Mesh ) ) . colors as * const _ as usize }
                , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( Mesh ) , "::" ,
                stringify ! ( colors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Mesh ) ) . indices as * const _ as usize
                } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( Mesh ) , "::" ,
                stringify ! ( indices ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Mesh ) ) . vaoId as * const _ as usize }
                , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( Mesh ) , "::" ,
                stringify ! ( vaoId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Mesh ) ) . vboId as * const _ as usize }
                , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( Mesh ) , "::" ,
                stringify ! ( vboId ) ));
}
impl Clone for Mesh {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Shader {
    pub id: ::std::os::raw::c_uint,
    pub vertexLoc: ::std::os::raw::c_int,
    pub texcoordLoc: ::std::os::raw::c_int,
    pub texcoord2Loc: ::std::os::raw::c_int,
    pub normalLoc: ::std::os::raw::c_int,
    pub tangentLoc: ::std::os::raw::c_int,
    pub colorLoc: ::std::os::raw::c_int,
    pub mvpLoc: ::std::os::raw::c_int,
    pub colDiffuseLoc: ::std::os::raw::c_int,
    pub colAmbientLoc: ::std::os::raw::c_int,
    pub colSpecularLoc: ::std::os::raw::c_int,
    pub mapTexture0Loc: ::std::os::raw::c_int,
    pub mapTexture1Loc: ::std::os::raw::c_int,
    pub mapTexture2Loc: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Shader() {
    assert_eq!(::std::mem::size_of::<Shader>() , 56usize , concat ! (
               "Size of: " , stringify ! ( Shader ) ));
    assert_eq! (::std::mem::align_of::<Shader>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( Shader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Shader ) ) . id as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( Shader ) , "::" ,
                stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Shader ) ) . vertexLoc as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( Shader ) , "::" ,
                stringify ! ( vertexLoc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Shader ) ) . texcoordLoc as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Shader ) , "::" ,
                stringify ! ( texcoordLoc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Shader ) ) . texcoord2Loc as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( Shader ) , "::" ,
                stringify ! ( texcoord2Loc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Shader ) ) . normalLoc as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( Shader ) , "::" ,
                stringify ! ( normalLoc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Shader ) ) . tangentLoc as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( Shader ) , "::" ,
                stringify ! ( tangentLoc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Shader ) ) . colorLoc as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( Shader ) , "::" ,
                stringify ! ( colorLoc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Shader ) ) . mvpLoc as * const _ as usize
                } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( Shader ) , "::" ,
                stringify ! ( mvpLoc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Shader ) ) . colDiffuseLoc as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( Shader ) , "::" ,
                stringify ! ( colDiffuseLoc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Shader ) ) . colAmbientLoc as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( Shader ) , "::" ,
                stringify ! ( colAmbientLoc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Shader ) ) . colSpecularLoc as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( Shader ) , "::" ,
                stringify ! ( colSpecularLoc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Shader ) ) . mapTexture0Loc as * const _
                as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( Shader ) , "::" ,
                stringify ! ( mapTexture0Loc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Shader ) ) . mapTexture1Loc as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( Shader ) , "::" ,
                stringify ! ( mapTexture1Loc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Shader ) ) . mapTexture2Loc as * const _
                as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( Shader ) , "::" ,
                stringify ! ( mapTexture2Loc ) ));
}
impl Clone for Shader {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Material {
    pub shader: Shader,
    pub texDiffuse: Texture2D,
    pub texNormal: Texture2D,
    pub texSpecular: Texture2D,
    pub colDiffuse: Color,
    pub colAmbient: Color,
    pub colSpecular: Color,
    pub glossiness: f32,
}
#[test]
fn bindgen_test_layout_Material() {
    assert_eq!(::std::mem::size_of::<Material>() , 132usize , concat ! (
               "Size of: " , stringify ! ( Material ) ));
    assert_eq! (::std::mem::align_of::<Material>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( Material ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Material ) ) . shader as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Material ) , "::" ,
                stringify ! ( shader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Material ) ) . texDiffuse as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( Material ) , "::" ,
                stringify ! ( texDiffuse ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Material ) ) . texNormal as * const _ as
                usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( Material ) , "::" ,
                stringify ! ( texNormal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Material ) ) . texSpecular as * const _
                as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( Material ) , "::" ,
                stringify ! ( texSpecular ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Material ) ) . colDiffuse as * const _ as
                usize } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( Material ) , "::" ,
                stringify ! ( colDiffuse ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Material ) ) . colAmbient as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( Material ) , "::" ,
                stringify ! ( colAmbient ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Material ) ) . colSpecular as * const _
                as usize } , 124usize , concat ! (
                "Alignment of field: " , stringify ! ( Material ) , "::" ,
                stringify ! ( colSpecular ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Material ) ) . glossiness as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( Material ) , "::" ,
                stringify ! ( glossiness ) ));
}
impl Clone for Material {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Model {
    pub mesh: Mesh,
    pub transform: Matrix,
    pub material: Material,
}
#[test]
fn bindgen_test_layout_Model() {
    assert_eq!(::std::mem::size_of::<Model>() , 296usize , concat ! (
               "Size of: " , stringify ! ( Model ) ));
    assert_eq! (::std::mem::align_of::<Model>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Model ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Model ) ) . mesh as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Model ) , "::" ,
                stringify ! ( mesh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Model ) ) . transform as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( Model ) , "::" ,
                stringify ! ( transform ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Model ) ) . material as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( Model ) , "::" ,
                stringify ! ( material ) ));
}
impl Clone for Model {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Ray {
    pub position: Vector3,
    pub direction: Vector3,
}
#[test]
fn bindgen_test_layout_Ray() {
    assert_eq!(::std::mem::size_of::<Ray>() , 24usize , concat ! (
               "Size of: " , stringify ! ( Ray ) ));
    assert_eq! (::std::mem::align_of::<Ray>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( Ray ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Ray ) ) . position as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Ray ) , "::" ,
                stringify ! ( position ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Ray ) ) . direction as * const _ as usize
                } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( Ray ) , "::" ,
                stringify ! ( direction ) ));
}
impl Clone for Ray {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RayHitInfo {
    pub hit: bool_,
    pub distance: f32,
    pub position: Vector3,
    pub normal: Vector3,
}
#[test]
fn bindgen_test_layout_RayHitInfo() {
    assert_eq!(::std::mem::size_of::<RayHitInfo>() , 32usize , concat ! (
               "Size of: " , stringify ! ( RayHitInfo ) ));
    assert_eq! (::std::mem::align_of::<RayHitInfo>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( RayHitInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RayHitInfo ) ) . hit as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RayHitInfo ) , "::" ,
                stringify ! ( hit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RayHitInfo ) ) . distance as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( RayHitInfo ) , "::" ,
                stringify ! ( distance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RayHitInfo ) ) . position as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( RayHitInfo ) , "::" ,
                stringify ! ( position ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RayHitInfo ) ) . normal as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( RayHitInfo ) , "::" ,
                stringify ! ( normal ) ));
}
impl Clone for RayHitInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Wave {
    pub sampleCount: ::std::os::raw::c_uint,
    pub sampleRate: ::std::os::raw::c_uint,
    pub sampleSize: ::std::os::raw::c_uint,
    pub channels: ::std::os::raw::c_uint,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_Wave() {
    assert_eq!(::std::mem::size_of::<Wave>() , 24usize , concat ! (
               "Size of: " , stringify ! ( Wave ) ));
    assert_eq! (::std::mem::align_of::<Wave>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Wave ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Wave ) ) . sampleCount as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Wave ) , "::" ,
                stringify ! ( sampleCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Wave ) ) . sampleRate as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( Wave ) , "::" ,
                stringify ! ( sampleRate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Wave ) ) . sampleSize as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Wave ) , "::" ,
                stringify ! ( sampleSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Wave ) ) . channels as * const _ as usize
                } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( Wave ) , "::" ,
                stringify ! ( channels ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Wave ) ) . data as * const _ as usize } ,
                16usize , concat ! (
                "Alignment of field: " , stringify ! ( Wave ) , "::" ,
                stringify ! ( data ) ));
}
impl Clone for Wave {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Sound {
    pub source: ::std::os::raw::c_uint,
    pub buffer: ::std::os::raw::c_uint,
    pub format: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Sound() {
    assert_eq!(::std::mem::size_of::<Sound>() , 12usize , concat ! (
               "Size of: " , stringify ! ( Sound ) ));
    assert_eq! (::std::mem::align_of::<Sound>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( Sound ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Sound ) ) . source as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Sound ) , "::" ,
                stringify ! ( source ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Sound ) ) . buffer as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( Sound ) , "::" ,
                stringify ! ( buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Sound ) ) . format as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Sound ) , "::" ,
                stringify ! ( format ) ));
}
impl Clone for Sound {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MusicData {
    _unused: [u8; 0],
}
pub type Music = *mut MusicData;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AudioStream {
    pub sampleRate: ::std::os::raw::c_uint,
    pub sampleSize: ::std::os::raw::c_uint,
    pub channels: ::std::os::raw::c_uint,
    pub format: ::std::os::raw::c_int,
    pub source: ::std::os::raw::c_uint,
    pub buffers: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout_AudioStream() {
    assert_eq!(::std::mem::size_of::<AudioStream>() , 28usize , concat ! (
               "Size of: " , stringify ! ( AudioStream ) ));
    assert_eq! (::std::mem::align_of::<AudioStream>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( AudioStream ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AudioStream ) ) . sampleRate as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AudioStream ) , "::" ,
                stringify ! ( sampleRate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AudioStream ) ) . sampleSize as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( AudioStream ) , "::" ,
                stringify ! ( sampleSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AudioStream ) ) . channels as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AudioStream ) , "::" ,
                stringify ! ( channels ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AudioStream ) ) . format as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( AudioStream ) , "::" ,
                stringify ! ( format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AudioStream ) ) . source as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AudioStream ) , "::" ,
                stringify ! ( source ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AudioStream ) ) . buffers as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( AudioStream ) , "::" ,
                stringify ! ( buffers ) ));
}
impl Clone for AudioStream {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RRESData {
    pub type_: ::std::os::raw::c_uint,
    pub param1: ::std::os::raw::c_uint,
    pub param2: ::std::os::raw::c_uint,
    pub param3: ::std::os::raw::c_uint,
    pub param4: ::std::os::raw::c_uint,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_RRESData() {
    assert_eq!(::std::mem::size_of::<RRESData>() , 32usize , concat ! (
               "Size of: " , stringify ! ( RRESData ) ));
    assert_eq! (::std::mem::align_of::<RRESData>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( RRESData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RRESData ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RRESData ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RRESData ) ) . param1 as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( RRESData ) , "::" ,
                stringify ! ( param1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RRESData ) ) . param2 as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( RRESData ) , "::" ,
                stringify ! ( param2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RRESData ) ) . param3 as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( RRESData ) , "::" ,
                stringify ! ( param3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RRESData ) ) . param4 as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( RRESData ) , "::" ,
                stringify ! ( param4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RRESData ) ) . data as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( RRESData ) , "::" ,
                stringify ! ( data ) ));
}
impl Clone for RRESData {
    fn clone(&self) -> Self { *self }
}
pub type RRES = *mut RRESData;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum LogType { INFO = 0, WARNING = 1, ERROR = 2, DEBUG = 3, OTHER = 4, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum TextureFormat {
    UNCOMPRESSED_GRAYSCALE = 1,
    UNCOMPRESSED_GRAY_ALPHA = 2,
    UNCOMPRESSED_R5G6B5 = 3,
    UNCOMPRESSED_R8G8B8 = 4,
    UNCOMPRESSED_R5G5B5A1 = 5,
    UNCOMPRESSED_R4G4B4A4 = 6,
    UNCOMPRESSED_R8G8B8A8 = 7,
    UNCOMPRESSED_R32G32B32 = 8,
    COMPRESSED_DXT1_RGB = 9,
    COMPRESSED_DXT1_RGBA = 10,
    COMPRESSED_DXT3_RGBA = 11,
    COMPRESSED_DXT5_RGBA = 12,
    COMPRESSED_ETC1_RGB = 13,
    COMPRESSED_ETC2_RGB = 14,
    COMPRESSED_ETC2_EAC_RGBA = 15,
    COMPRESSED_PVRT_RGB = 16,
    COMPRESSED_PVRT_RGBA = 17,
    COMPRESSED_ASTC_4x4_RGBA = 18,
    COMPRESSED_ASTC_8x8_RGBA = 19,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum TextureFilterMode {
    FILTER_POINT = 0,
    FILTER_BILINEAR = 1,
    FILTER_TRILINEAR = 2,
    FILTER_ANISOTROPIC_4X = 3,
    FILTER_ANISOTROPIC_8X = 4,
    FILTER_ANISOTROPIC_16X = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum TextureWrapMode { WRAP_REPEAT = 0, WRAP_CLAMP = 1, WRAP_MIRROR = 2, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum BlendMode {
    BLEND_ALPHA = 0,
    BLEND_ADDITIVE = 1,
    BLEND_MULTIPLIED = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum Gestures {
    GESTURE_NONE = 0,
    GESTURE_TAP = 1,
    GESTURE_DOUBLETAP = 2,
    GESTURE_HOLD = 4,
    GESTURE_DRAG = 8,
    GESTURE_SWIPE_RIGHT = 16,
    GESTURE_SWIPE_LEFT = 32,
    GESTURE_SWIPE_UP = 64,
    GESTURE_SWIPE_DOWN = 128,
    GESTURE_PINCH_IN = 256,
    GESTURE_PINCH_OUT = 512,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CameraMode {
    CAMERA_CUSTOM = 0,
    CAMERA_FREE = 1,
    CAMERA_ORBITAL = 2,
    CAMERA_FIRST_PERSON = 3,
    CAMERA_THIRD_PERSON = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VrDevice {
    HMD_DEFAULT_DEVICE = 0,
    HMD_OCULUS_RIFT_DK2 = 1,
    HMD_OCULUS_RIFT_CV1 = 2,
    HMD_VALVE_HTC_VIVE = 3,
    HMD_SAMSUNG_GEAR_VR = 4,
    HMD_GOOGLE_CARDBOARD = 5,
    HMD_SONY_PLAYSTATION_VR = 6,
    HMD_RAZER_OSVR = 7,
    HMD_FOVE_VR = 8,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RRESDataType {
    RRES_TYPE_RAW = 0,
    RRES_TYPE_IMAGE = 1,
    RRES_TYPE_WAVE = 2,
    RRES_TYPE_VERTEX = 3,
    RRES_TYPE_TEXT = 4,
    RRES_TYPE_FONT_IMAGE = 5,
    RRES_TYPE_FONT_CHARDATA = 6,
    RRES_TYPE_DIRECTORY = 7,
}
#[link(name = "raylib")]
#[link(name = "GL")]
#[link(name = "glfw")]
#[link(name = "openal")]
extern "C" {
    pub fn InitWindow(width: ::std::os::raw::c_int,
                      height: ::std::os::raw::c_int,
                      title: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn CloseWindow();
}
extern "C" {
    pub fn WindowShouldClose() -> bool_;
}
extern "C" {
    pub fn IsWindowMinimized() -> bool_;
}
extern "C" {
    pub fn ToggleFullscreen();
}
extern "C" {
    pub fn SetWindowIcon(image: Image);
}
extern "C" {
    pub fn SetWindowPosition(x: ::std::os::raw::c_int,
                             y: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SetWindowMonitor(monitor: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SetWindowMinSize(width: ::std::os::raw::c_int,
                            height: ::std::os::raw::c_int);
}
extern "C" {
    pub fn GetScreenWidth() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetScreenHeight() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ShowCursor();
}
extern "C" {
    pub fn HideCursor();
}
extern "C" {
    pub fn IsCursorHidden() -> bool_;
}
extern "C" {
    pub fn EnableCursor();
}
extern "C" {
    pub fn DisableCursor();
}
extern "C" {
    pub fn ClearBackground(color: Color);
}
extern "C" {
    pub fn BeginDrawing();
}
extern "C" {
    pub fn EndDrawing();
}
extern "C" {
    pub fn Begin2dMode(camera: Camera2D);
}
extern "C" {
    pub fn End2dMode();
}
extern "C" {
    pub fn Begin3dMode(camera: Camera);
}
extern "C" {
    pub fn End3dMode();
}
extern "C" {
    pub fn BeginTextureMode(target: RenderTexture2D);
}
extern "C" {
    pub fn EndTextureMode();
}
extern "C" {
    pub fn GetMouseRay(mousePosition: Vector2, camera: Camera) -> Ray;
}
extern "C" {
    pub fn GetWorldToScreen(position: Vector3, camera: Camera) -> Vector2;
}
extern "C" {
    pub fn GetCameraMatrix(camera: Camera) -> Matrix;
}
extern "C" {
    pub fn SetTargetFPS(fps: ::std::os::raw::c_int);
}
extern "C" {
    pub fn GetFPS() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetFrameTime() -> f32;
}
extern "C" {
    pub fn GetHexValue(color: Color) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetColor(hexValue: ::std::os::raw::c_int) -> Color;
}
extern "C" {
    pub fn Fade(color: Color, alpha: f32) -> Color;
}
extern "C" {
    pub fn ColorToFloat(color: Color) -> *mut f32;
}
extern "C" {
    pub fn VectorToFloat(vec: Vector3) -> *mut f32;
}
extern "C" {
    pub fn MatrixToFloat(mat: Matrix) -> *mut f32;
}
extern "C" {
    pub fn ShowLogo();
}
extern "C" {
    pub fn SetConfigFlags(flags: ::std::os::raw::c_char);
}
extern "C" {
    pub fn TraceLog(logType: ::std::os::raw::c_int,
                    text: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn TakeScreenshot(fileName: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn GetRandomValue(min: ::std::os::raw::c_int,
                          max: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn IsFileExtension(fileName: *const ::std::os::raw::c_char,
                           ext: *const ::std::os::raw::c_char) -> bool_;
}
extern "C" {
    pub fn GetDirectoryPath(fileName: *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn GetWorkingDirectory() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ChangeDirectory(dir: *const ::std::os::raw::c_char) -> bool_;
}
extern "C" {
    pub fn IsFileDropped() -> bool_;
}
extern "C" {
    pub fn GetDroppedFiles(count: *mut ::std::os::raw::c_int)
     -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ClearDroppedFiles();
}
extern "C" {
    pub fn StorageSaveValue(position: ::std::os::raw::c_int,
                            value: ::std::os::raw::c_int);
}
extern "C" {
    pub fn StorageLoadValue(position: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn IsKeyPressed(key: ::std::os::raw::c_int) -> bool_;
}
extern "C" {
    pub fn IsKeyDown(key: ::std::os::raw::c_int) -> bool_;
}
extern "C" {
    pub fn IsKeyReleased(key: ::std::os::raw::c_int) -> bool_;
}
extern "C" {
    pub fn IsKeyUp(key: ::std::os::raw::c_int) -> bool_;
}
extern "C" {
    pub fn GetKeyPressed() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SetExitKey(key: ::std::os::raw::c_int);
}
extern "C" {
    pub fn IsGamepadAvailable(gamepad: ::std::os::raw::c_int) -> bool_;
}
extern "C" {
    pub fn IsGamepadName(gamepad: ::std::os::raw::c_int,
                         name: *const ::std::os::raw::c_char) -> bool_;
}
extern "C" {
    pub fn GetGamepadName(gamepad: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn IsGamepadButtonPressed(gamepad: ::std::os::raw::c_int,
                                  button: ::std::os::raw::c_int) -> bool_;
}
extern "C" {
    pub fn IsGamepadButtonDown(gamepad: ::std::os::raw::c_int,
                               button: ::std::os::raw::c_int) -> bool_;
}
extern "C" {
    pub fn IsGamepadButtonReleased(gamepad: ::std::os::raw::c_int,
                                   button: ::std::os::raw::c_int) -> bool_;
}
extern "C" {
    pub fn IsGamepadButtonUp(gamepad: ::std::os::raw::c_int,
                             button: ::std::os::raw::c_int) -> bool_;
}
extern "C" {
    pub fn GetGamepadButtonPressed() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetGamepadAxisCount(gamepad: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetGamepadAxisMovement(gamepad: ::std::os::raw::c_int,
                                  axis: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn IsMouseButtonPressed(button: ::std::os::raw::c_int) -> bool_;
}
extern "C" {
    pub fn IsMouseButtonDown(button: ::std::os::raw::c_int) -> bool_;
}
extern "C" {
    pub fn IsMouseButtonReleased(button: ::std::os::raw::c_int) -> bool_;
}
extern "C" {
    pub fn IsMouseButtonUp(button: ::std::os::raw::c_int) -> bool_;
}
extern "C" {
    pub fn GetMouseX() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetMouseY() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetMousePosition() -> Vector2;
}
extern "C" {
    pub fn SetMousePosition(position: Vector2);
}
extern "C" {
    pub fn GetMouseWheelMove() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetTouchX() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetTouchY() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetTouchPosition(index: ::std::os::raw::c_int) -> Vector2;
}
extern "C" {
    pub fn SetGesturesEnabled(gestureFlags: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn IsGestureDetected(gesture: ::std::os::raw::c_int) -> bool_;
}
extern "C" {
    pub fn GetGestureDetected() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetTouchPointsCount() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetGestureHoldDuration() -> f32;
}
extern "C" {
    pub fn GetGestureDragVector() -> Vector2;
}
extern "C" {
    pub fn GetGestureDragAngle() -> f32;
}
extern "C" {
    pub fn GetGesturePinchVector() -> Vector2;
}
extern "C" {
    pub fn GetGesturePinchAngle() -> f32;
}
extern "C" {
    pub fn SetCameraMode(camera: Camera, mode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn UpdateCamera(camera: *mut Camera);
}
extern "C" {
    pub fn SetCameraPanControl(panKey: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SetCameraAltControl(altKey: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SetCameraSmoothZoomControl(szKey: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SetCameraMoveControls(frontKey: ::std::os::raw::c_int,
                                 backKey: ::std::os::raw::c_int,
                                 rightKey: ::std::os::raw::c_int,
                                 leftKey: ::std::os::raw::c_int,
                                 upKey: ::std::os::raw::c_int,
                                 downKey: ::std::os::raw::c_int);
}
extern "C" {
    pub fn DrawPixel(posX: ::std::os::raw::c_int, posY: ::std::os::raw::c_int,
                     color: Color);
}
extern "C" {
    pub fn DrawPixelV(position: Vector2, color: Color);
}
extern "C" {
    pub fn DrawLine(startPosX: ::std::os::raw::c_int,
                    startPosY: ::std::os::raw::c_int,
                    endPosX: ::std::os::raw::c_int,
                    endPosY: ::std::os::raw::c_int, color: Color);
}
extern "C" {
    pub fn DrawLineV(startPos: Vector2, endPos: Vector2, color: Color);
}
extern "C" {
    pub fn DrawLineEx(startPos: Vector2, endPos: Vector2, thick: f32,
                      color: Color);
}
extern "C" {
    pub fn DrawLineBezier(startPos: Vector2, endPos: Vector2, thick: f32,
                          color: Color);
}
extern "C" {
    pub fn DrawCircle(centerX: ::std::os::raw::c_int,
                      centerY: ::std::os::raw::c_int, radius: f32,
                      color: Color);
}
extern "C" {
    pub fn DrawCircleGradient(centerX: ::std::os::raw::c_int,
                              centerY: ::std::os::raw::c_int, radius: f32,
                              color1: Color, color2: Color);
}
extern "C" {
    pub fn DrawCircleV(center: Vector2, radius: f32, color: Color);
}
extern "C" {
    pub fn DrawCircleLines(centerX: ::std::os::raw::c_int,
                           centerY: ::std::os::raw::c_int, radius: f32,
                           color: Color);
}
extern "C" {
    pub fn DrawRectangle(posX: ::std::os::raw::c_int,
                         posY: ::std::os::raw::c_int,
                         width: ::std::os::raw::c_int,
                         height: ::std::os::raw::c_int, color: Color);
}
extern "C" {
    pub fn DrawRectangleRec(rec: Rectangle, color: Color);
}
extern "C" {
    pub fn DrawRectanglePro(rec: Rectangle, origin: Vector2, rotation: f32,
                            color: Color);
}
extern "C" {
    pub fn DrawRectangleGradient(posX: ::std::os::raw::c_int,
                                 posY: ::std::os::raw::c_int,
                                 width: ::std::os::raw::c_int,
                                 height: ::std::os::raw::c_int, color1: Color,
                                 color2: Color);
}
extern "C" {
    pub fn DrawRectangleV(position: Vector2, size: Vector2, color: Color);
}
extern "C" {
    pub fn DrawRectangleLines(posX: ::std::os::raw::c_int,
                              posY: ::std::os::raw::c_int,
                              width: ::std::os::raw::c_int,
                              height: ::std::os::raw::c_int, color: Color);
}
extern "C" {
    pub fn DrawTriangle(v1: Vector2, v2: Vector2, v3: Vector2, color: Color);
}
extern "C" {
    pub fn DrawTriangleLines(v1: Vector2, v2: Vector2, v3: Vector2,
                             color: Color);
}
extern "C" {
    pub fn DrawPoly(center: Vector2, sides: ::std::os::raw::c_int,
                    radius: f32, rotation: f32, color: Color);
}
extern "C" {
    pub fn DrawPolyEx(points: *mut Vector2, numPoints: ::std::os::raw::c_int,
                      color: Color);
}
extern "C" {
    pub fn DrawPolyExLines(points: *mut Vector2,
                           numPoints: ::std::os::raw::c_int, color: Color);
}
extern "C" {
    pub fn CheckCollisionRecs(rec1: Rectangle, rec2: Rectangle) -> bool_;
}
extern "C" {
    pub fn CheckCollisionCircles(center1: Vector2, radius1: f32,
                                 center2: Vector2, radius2: f32) -> bool_;
}
extern "C" {
    pub fn CheckCollisionCircleRec(center: Vector2, radius: f32,
                                   rec: Rectangle) -> bool_;
}
extern "C" {
    pub fn GetCollisionRec(rec1: Rectangle, rec2: Rectangle) -> Rectangle;
}
extern "C" {
    pub fn CheckCollisionPointRec(point: Vector2, rec: Rectangle) -> bool_;
}
extern "C" {
    pub fn CheckCollisionPointCircle(point: Vector2, center: Vector2,
                                     radius: f32) -> bool_;
}
extern "C" {
    pub fn CheckCollisionPointTriangle(point: Vector2, p1: Vector2,
                                       p2: Vector2, p3: Vector2) -> bool_;
}
extern "C" {
    pub fn LoadImage(fileName: *const ::std::os::raw::c_char) -> Image;
}
extern "C" {
    pub fn LoadImageEx(pixels: *mut Color, width: ::std::os::raw::c_int,
                       height: ::std::os::raw::c_int) -> Image;
}
extern "C" {
    pub fn LoadImagePro(data: *mut ::std::os::raw::c_void,
                        width: ::std::os::raw::c_int,
                        height: ::std::os::raw::c_int,
                        format: ::std::os::raw::c_int) -> Image;
}
extern "C" {
    pub fn LoadImageRaw(fileName: *const ::std::os::raw::c_char,
                        width: ::std::os::raw::c_int,
                        height: ::std::os::raw::c_int,
                        format: ::std::os::raw::c_int,
                        headerSize: ::std::os::raw::c_int) -> Image;
}
extern "C" {
    pub fn LoadTexture(fileName: *const ::std::os::raw::c_char) -> Texture2D;
}
extern "C" {
    pub fn LoadTextureFromImage(image: Image) -> Texture2D;
}
extern "C" {
    pub fn LoadRenderTexture(width: ::std::os::raw::c_int,
                             height: ::std::os::raw::c_int)
     -> RenderTexture2D;
}
extern "C" {
    pub fn UnloadImage(image: Image);
}
extern "C" {
    pub fn UnloadTexture(texture: Texture2D);
}
extern "C" {
    pub fn UnloadRenderTexture(target: RenderTexture2D);
}
extern "C" {
    pub fn GetImageData(image: Image) -> *mut Color;
}
extern "C" {
    pub fn GetTextureData(texture: Texture2D) -> Image;
}
extern "C" {
    pub fn UpdateTexture(texture: Texture2D,
                         pixels: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn ImageToPOT(image: *mut Image, fillColor: Color);
}
extern "C" {
    pub fn ImageFormat(image: *mut Image, newFormat: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ImageAlphaMask(image: *mut Image, alphaMask: Image);
}
extern "C" {
    pub fn ImageDither(image: *mut Image, rBpp: ::std::os::raw::c_int,
                       gBpp: ::std::os::raw::c_int,
                       bBpp: ::std::os::raw::c_int,
                       aBpp: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ImageCopy(image: Image) -> Image;
}
extern "C" {
    pub fn ImageCrop(image: *mut Image, crop: Rectangle);
}
extern "C" {
    pub fn ImageResize(image: *mut Image, newWidth: ::std::os::raw::c_int,
                       newHeight: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ImageResizeNN(image: *mut Image, newWidth: ::std::os::raw::c_int,
                         newHeight: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ImageText(text: *const ::std::os::raw::c_char,
                     fontSize: ::std::os::raw::c_int, color: Color) -> Image;
}
extern "C" {
    pub fn ImageTextEx(font: SpriteFont, text: *const ::std::os::raw::c_char,
                       fontSize: f32, spacing: ::std::os::raw::c_int,
                       tint: Color) -> Image;
}
extern "C" {
    pub fn ImageDraw(dst: *mut Image, src: Image, srcRec: Rectangle,
                     dstRec: Rectangle);
}
extern "C" {
    pub fn ImageDrawText(dst: *mut Image, position: Vector2,
                         text: *const ::std::os::raw::c_char,
                         fontSize: ::std::os::raw::c_int, color: Color);
}
extern "C" {
    pub fn ImageDrawTextEx(dst: *mut Image, position: Vector2,
                           font: SpriteFont,
                           text: *const ::std::os::raw::c_char, fontSize: f32,
                           spacing: ::std::os::raw::c_int, color: Color);
}
extern "C" {
    pub fn ImageFlipVertical(image: *mut Image);
}
extern "C" {
    pub fn ImageFlipHorizontal(image: *mut Image);
}
extern "C" {
    pub fn ImageColorTint(image: *mut Image, color: Color);
}
extern "C" {
    pub fn ImageColorInvert(image: *mut Image);
}
extern "C" {
    pub fn ImageColorGrayscale(image: *mut Image);
}
extern "C" {
    pub fn ImageColorContrast(image: *mut Image, contrast: f32);
}
extern "C" {
    pub fn ImageColorBrightness(image: *mut Image,
                                brightness: ::std::os::raw::c_int);
}
extern "C" {
    pub fn GenTextureMipmaps(texture: *mut Texture2D);
}
extern "C" {
    pub fn SetTextureFilter(texture: Texture2D,
                            filterMode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SetTextureWrap(texture: Texture2D,
                          wrapMode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn DrawTexture(texture: Texture2D, posX: ::std::os::raw::c_int,
                       posY: ::std::os::raw::c_int, tint: Color);
}
extern "C" {
    pub fn DrawTextureV(texture: Texture2D, position: Vector2, tint: Color);
}
extern "C" {
    pub fn DrawTextureEx(texture: Texture2D, position: Vector2, rotation: f32,
                         scale: f32, tint: Color);
}
extern "C" {
    pub fn DrawTextureRec(texture: Texture2D, sourceRec: Rectangle,
                          position: Vector2, tint: Color);
}
extern "C" {
    pub fn DrawTexturePro(texture: Texture2D, sourceRec: Rectangle,
                          destRec: Rectangle, origin: Vector2, rotation: f32,
                          tint: Color);
}
extern "C" {
    pub fn GetDefaultFont() -> SpriteFont;
}
extern "C" {
    pub fn LoadSpriteFont(fileName: *const ::std::os::raw::c_char)
     -> SpriteFont;
}
extern "C" {
    pub fn LoadSpriteFontEx(fileName: *const ::std::os::raw::c_char,
                            fontSize: ::std::os::raw::c_int,
                            charsCount: ::std::os::raw::c_int,
                            fontChars: *mut ::std::os::raw::c_int)
     -> SpriteFont;
}
extern "C" {
    pub fn UnloadSpriteFont(spriteFont: SpriteFont);
}
extern "C" {
    pub fn DrawFPS(posX: ::std::os::raw::c_int, posY: ::std::os::raw::c_int);
}
extern "C" {
    pub fn DrawText(text: *const ::std::os::raw::c_char,
                    posX: ::std::os::raw::c_int, posY: ::std::os::raw::c_int,
                    fontSize: ::std::os::raw::c_int, color: Color);
}
extern "C" {
    pub fn DrawTextEx(spriteFont: SpriteFont,
                      text: *const ::std::os::raw::c_char, position: Vector2,
                      fontSize: f32, spacing: ::std::os::raw::c_int,
                      tint: Color);
}
extern "C" {
    pub fn MeasureText(text: *const ::std::os::raw::c_char,
                       fontSize: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn MeasureTextEx(spriteFont: SpriteFont,
                         text: *const ::std::os::raw::c_char, fontSize: f32,
                         spacing: ::std::os::raw::c_int) -> Vector2;
}
extern "C" {
    pub fn FormatText(text: *const ::std::os::raw::c_char, ...)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SubText(text: *const ::std::os::raw::c_char,
                   position: ::std::os::raw::c_int,
                   length: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn DrawLine3D(startPos: Vector3, endPos: Vector3, color: Color);
}
extern "C" {
    pub fn DrawCircle3D(center: Vector3, radius: f32, rotationAxis: Vector3,
                        rotationAngle: f32, color: Color);
}
extern "C" {
    pub fn DrawCube(position: Vector3, width: f32, height: f32, length: f32,
                    color: Color);
}
extern "C" {
    pub fn DrawCubeV(position: Vector3, size: Vector3, color: Color);
}
extern "C" {
    pub fn DrawCubeWires(position: Vector3, width: f32, height: f32,
                         length: f32, color: Color);
}
extern "C" {
    pub fn DrawCubeTexture(texture: Texture2D, position: Vector3, width: f32,
                           height: f32, length: f32, color: Color);
}
extern "C" {
    pub fn DrawSphere(centerPos: Vector3, radius: f32, color: Color);
}
extern "C" {
    pub fn DrawSphereEx(centerPos: Vector3, radius: f32,
                        rings: ::std::os::raw::c_int,
                        slices: ::std::os::raw::c_int, color: Color);
}
extern "C" {
    pub fn DrawSphereWires(centerPos: Vector3, radius: f32,
                           rings: ::std::os::raw::c_int,
                           slices: ::std::os::raw::c_int, color: Color);
}
extern "C" {
    pub fn DrawCylinder(position: Vector3, radiusTop: f32, radiusBottom: f32,
                        height: f32, slices: ::std::os::raw::c_int,
                        color: Color);
}
extern "C" {
    pub fn DrawCylinderWires(position: Vector3, radiusTop: f32,
                             radiusBottom: f32, height: f32,
                             slices: ::std::os::raw::c_int, color: Color);
}
extern "C" {
    pub fn DrawPlane(centerPos: Vector3, size: Vector2, color: Color);
}
extern "C" {
    pub fn DrawRay(ray: Ray, color: Color);
}
extern "C" {
    pub fn DrawGrid(slices: ::std::os::raw::c_int, spacing: f32);
}
extern "C" {
    pub fn DrawGizmo(position: Vector3);
}
extern "C" {
    pub fn LoadMesh(fileName: *const ::std::os::raw::c_char) -> Mesh;
}
extern "C" {
    pub fn LoadMeshEx(numVertex: ::std::os::raw::c_int, vData: *mut f32,
                      vtData: *mut f32, vnData: *mut f32, cData: *mut Color)
     -> Mesh;
}
extern "C" {
    pub fn LoadModel(fileName: *const ::std::os::raw::c_char) -> Model;
}
extern "C" {
    pub fn LoadModelFromMesh(data: Mesh, dynamic: bool_) -> Model;
}
extern "C" {
    pub fn LoadHeightmap(heightmap: Image, size: Vector3) -> Model;
}
extern "C" {
    pub fn LoadCubicmap(cubicmap: Image) -> Model;
}
extern "C" {
    pub fn UnloadMesh(mesh: *mut Mesh);
}
extern "C" {
    pub fn UnloadModel(model: Model);
}
extern "C" {
    pub fn LoadMaterial(fileName: *const ::std::os::raw::c_char) -> Material;
}
extern "C" {
    pub fn LoadDefaultMaterial() -> Material;
}
extern "C" {
    pub fn UnloadMaterial(material: Material);
}
extern "C" {
    pub fn DrawModel(model: Model, position: Vector3, scale: f32,
                     tint: Color);
}
extern "C" {
    pub fn DrawModelEx(model: Model, position: Vector3, rotationAxis: Vector3,
                       rotationAngle: f32, scale: Vector3, tint: Color);
}
extern "C" {
    pub fn DrawModelWires(model: Model, position: Vector3, scale: f32,
                          tint: Color);
}
extern "C" {
    pub fn DrawModelWiresEx(model: Model, position: Vector3,
                            rotationAxis: Vector3, rotationAngle: f32,
                            scale: Vector3, tint: Color);
}
extern "C" {
    pub fn DrawBoundingBox(box_: BoundingBox, color: Color);
}
extern "C" {
    pub fn DrawBillboard(camera: Camera, texture: Texture2D, center: Vector3,
                         size: f32, tint: Color);
}
extern "C" {
    pub fn DrawBillboardRec(camera: Camera, texture: Texture2D,
                            sourceRec: Rectangle, center: Vector3, size: f32,
                            tint: Color);
}
extern "C" {
    pub fn CalculateBoundingBox(mesh: Mesh) -> BoundingBox;
}
extern "C" {
    pub fn CheckCollisionSpheres(centerA: Vector3, radiusA: f32,
                                 centerB: Vector3, radiusB: f32) -> bool_;
}
extern "C" {
    pub fn CheckCollisionBoxes(box1: BoundingBox, box2: BoundingBox) -> bool_;
}
extern "C" {
    pub fn CheckCollisionBoxSphere(box_: BoundingBox, centerSphere: Vector3,
                                   radiusSphere: f32) -> bool_;
}
extern "C" {
    pub fn CheckCollisionRaySphere(ray: Ray, spherePosition: Vector3,
                                   sphereRadius: f32) -> bool_;
}
extern "C" {
    pub fn CheckCollisionRaySphereEx(ray: Ray, spherePosition: Vector3,
                                     sphereRadius: f32,
                                     collisionPoint: *mut Vector3) -> bool_;
}
extern "C" {
    pub fn CheckCollisionRayBox(ray: Ray, box_: BoundingBox) -> bool_;
}
extern "C" {
    pub fn GetCollisionRayMesh(ray: Ray, mesh: *mut Mesh) -> RayHitInfo;
}
extern "C" {
    pub fn GetCollisionRayTriangle(ray: Ray, p1: Vector3, p2: Vector3,
                                   p3: Vector3) -> RayHitInfo;
}
extern "C" {
    pub fn GetCollisionRayGround(ray: Ray, groundHeight: f32) -> RayHitInfo;
}
extern "C" {
    pub fn LoadText(fileName: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn LoadShader(vsFileName: *mut ::std::os::raw::c_char,
                      fsFileName: *mut ::std::os::raw::c_char) -> Shader;
}
extern "C" {
    pub fn UnloadShader(shader: Shader);
}
extern "C" {
    pub fn GetDefaultShader() -> Shader;
}
extern "C" {
    pub fn GetDefaultTexture() -> Texture2D;
}
extern "C" {
    pub fn GetShaderLocation(shader: Shader,
                             uniformName: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SetShaderValue(shader: Shader, uniformLoc: ::std::os::raw::c_int,
                          value: *mut f32, size: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SetShaderValuei(shader: Shader, uniformLoc: ::std::os::raw::c_int,
                           value: *mut ::std::os::raw::c_int,
                           size: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SetShaderValueMatrix(shader: Shader,
                                uniformLoc: ::std::os::raw::c_int,
                                mat: Matrix);
}
extern "C" {
    pub fn SetMatrixProjection(proj: Matrix);
}
extern "C" {
    pub fn SetMatrixModelview(view: Matrix);
}
extern "C" {
    pub fn BeginShaderMode(shader: Shader);
}
extern "C" {
    pub fn EndShaderMode();
}
extern "C" {
    pub fn BeginBlendMode(mode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn EndBlendMode();
}
extern "C" {
    pub fn InitVrSimulator(vrDevice: ::std::os::raw::c_int);
}
extern "C" {
    pub fn CloseVrSimulator();
}
extern "C" {
    pub fn IsVrSimulatorReady() -> bool_;
}
extern "C" {
    pub fn UpdateVrTracking(camera: *mut Camera);
}
extern "C" {
    pub fn ToggleVrMode();
}
extern "C" {
    pub fn BeginVrDrawing();
}
extern "C" {
    pub fn EndVrDrawing();
}
extern "C" {
    pub fn InitAudioDevice();
}
extern "C" {
    pub fn CloseAudioDevice();
}
extern "C" {
    pub fn IsAudioDeviceReady() -> bool_;
}
extern "C" {
    pub fn SetMasterVolume(volume: f32);
}
extern "C" {
    pub fn LoadWave(fileName: *const ::std::os::raw::c_char) -> Wave;
}
extern "C" {
    pub fn LoadWaveEx(data: *mut ::std::os::raw::c_void,
                      sampleCount: ::std::os::raw::c_int,
                      sampleRate: ::std::os::raw::c_int,
                      sampleSize: ::std::os::raw::c_int,
                      channels: ::std::os::raw::c_int) -> Wave;
}
extern "C" {
    pub fn LoadSound(fileName: *const ::std::os::raw::c_char) -> Sound;
}
extern "C" {
    pub fn LoadSoundFromWave(wave: Wave) -> Sound;
}
extern "C" {
    pub fn UpdateSound(sound: Sound, data: *const ::std::os::raw::c_void,
                       samplesCount: ::std::os::raw::c_int);
}
extern "C" {
    pub fn UnloadWave(wave: Wave);
}
extern "C" {
    pub fn UnloadSound(sound: Sound);
}
extern "C" {
    pub fn PlaySound(sound: Sound);
}
extern "C" {
    pub fn PauseSound(sound: Sound);
}
extern "C" {
    pub fn ResumeSound(sound: Sound);
}
extern "C" {
    pub fn StopSound(sound: Sound);
}
extern "C" {
    pub fn IsSoundPlaying(sound: Sound) -> bool_;
}
extern "C" {
    pub fn SetSoundVolume(sound: Sound, volume: f32);
}
extern "C" {
    pub fn SetSoundPitch(sound: Sound, pitch: f32);
}
extern "C" {
    pub fn WaveFormat(wave: *mut Wave, sampleRate: ::std::os::raw::c_int,
                      sampleSize: ::std::os::raw::c_int,
                      channels: ::std::os::raw::c_int);
}
extern "C" {
    pub fn WaveCopy(wave: Wave) -> Wave;
}
extern "C" {
    pub fn WaveCrop(wave: *mut Wave, initSample: ::std::os::raw::c_int,
                    finalSample: ::std::os::raw::c_int);
}
extern "C" {
    pub fn GetWaveData(wave: Wave) -> *mut f32;
}
extern "C" {
    pub fn LoadMusicStream(fileName: *const ::std::os::raw::c_char) -> Music;
}
extern "C" {
    pub fn UnloadMusicStream(music: Music);
}
extern "C" {
    pub fn PlayMusicStream(music: Music);
}
extern "C" {
    pub fn UpdateMusicStream(music: Music);
}
extern "C" {
    pub fn StopMusicStream(music: Music);
}
extern "C" {
    pub fn PauseMusicStream(music: Music);
}
extern "C" {
    pub fn ResumeMusicStream(music: Music);
}
extern "C" {
    pub fn IsMusicPlaying(music: Music) -> bool_;
}
extern "C" {
    pub fn SetMusicVolume(music: Music, volume: f32);
}
extern "C" {
    pub fn SetMusicPitch(music: Music, pitch: f32);
}
extern "C" {
    pub fn SetMusicLoopCount(music: Music, count: f32);
}
extern "C" {
    pub fn GetMusicTimeLength(music: Music) -> f32;
}
extern "C" {
    pub fn GetMusicTimePlayed(music: Music) -> f32;
}
extern "C" {
    pub fn InitAudioStream(sampleRate: ::std::os::raw::c_uint,
                           sampleSize: ::std::os::raw::c_uint,
                           channels: ::std::os::raw::c_uint) -> AudioStream;
}
extern "C" {
    pub fn UpdateAudioStream(stream: AudioStream,
                             data: *const ::std::os::raw::c_void,
                             samplesCount: ::std::os::raw::c_int);
}
extern "C" {
    pub fn CloseAudioStream(stream: AudioStream);
}
extern "C" {
    pub fn IsAudioBufferProcessed(stream: AudioStream) -> bool_;
}
extern "C" {
    pub fn PlayAudioStream(stream: AudioStream);
}
extern "C" {
    pub fn PauseAudioStream(stream: AudioStream);
}
extern "C" {
    pub fn ResumeAudioStream(stream: AudioStream);
}
extern "C" {
    pub fn StopAudioStream(stream: AudioStream);
}
